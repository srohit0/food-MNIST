# -*- coding: utf-8 -*-
"""food_mnist.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1up6n5A9BhuKvEj9JWwn2CX35plsX1-U-

%%time
# clone food_mnist
! git clone https://github.com/srohit0/food_mnist.git
! ls food_mnist
"""
from __future__ import print_function
import os, sys
import cv2
import numpy as np
try:
    from google.colab.patches import cv2_imshow
except Exception as e:
    print ("module google.colab.patches not imported.")
    def cv2_imshow(image):
        cv2.imshow('food MNIST', image)

"""## labels()

---

**Returns:** dictionary of labels
"""

def labels():
  lbls = {}
  with open(os.path.join("food_mnist", "meta", "classes.txt")) as f:
    imgTags = [x.strip() for x in f.readlines()]
    lbls = {key: value for (key, value) in enumerate(imgTags)}

    return lbls

"""## iLabel(lblName, lblDict)

----

**Args:**

      lblName: string
      lblDict: dictionary of int:string values

**Returns:**

      integer enum corresponding to string label
"""

def iLabel(lblName, lblDict=None):
  if lblDict is None:
    lblDict = labels()

  for num in lblDict.keys():
    if lblDict[num] == lblName.lower():
      return num;

  return -1

#iLabel("bibimbap")

"""## transform_image(imgFileName, imgHeight, imgWidth)

----

**Args:**

      imageFileName: string
      imgHeight: integer, height of the images between as per ML model
      imgWidth : integer, width of the images between as per ML model

**Returns:**

      numpy array of the image with shape(imgHeight, imgWidth, 3)

 **Description**

This function transforms the original image to a new dimension keeping the maximum imformation in the returned image.
1. change (portrait/landscape) orientation of imageFile if necessary
2. find crop size scale, and crop image
3. resize to width and height
"""

def transform_image(imgFileName, height, width, show=False):

  image = cv2.imread(imgFileName)
  imageH, imageW, _ = image.shape
  if show:
    print(image.shape)
    cv2_imshow(image)

  if ( width <=0 or height <=0 ):
    return image

  # Step 1: change (portrait/landscape) orientation of imageFile if necessary
  if ( (width>height and imageW<imageH) or (width<height and imageW>imageH)):
    rotated_image = cv2.transpose(image)
    image=cv2.flip(rotated_image,flipCode=0)
    imageH, imageW, _ = image.shape
    if show:
      print(image.shape)
      cv2_imshow(image)

  # Step 2: find scale and crop the image
  scale = min(float(imageW)/width, float(imageH)/height)
  newWidth  = int(width*scale)
  newHeight = int(height*scale)
  if ( abs(scale-1.0) > sys.float_info.epsilon ):
    image = image[
              int((imageH-newHeight)/2):int((imageH+newHeight)/2),
              int((imageW-newWidth)/2):int((imageW+newWidth)/2)
            ]
    imageH, imageW, _ = image.shape
    if show:
      print(image.shape)
      cv2_imshow(image)

  # Step 3: resize to width and height
  if (image.shape[0] != height or image.shape[1] != width):
    image = cv2.resize(image,(width,height),interpolation=cv2.INTER_AREA)
    imageH, imageW, _ = image.shape
    if show:
      print(image.shape)
      cv2_imshow(image)

  return image;

#print(transform_image("food_mnist/images/apple_pie/134.jpg", 384, 512, True).shape)

"""## load_images(imageTagFileName, imgWidth, imgHeight)

----

**Args:**

      imageTagFileName: string
      imgWidth : integer, width of the images between as per ML model
      imgHeight: integer, height of the images between as per ML model

**Returns:**

      numpy array of the image with shape(numImages, imgHeight, imgWidth, 3)
      list of integers representing labels
"""

def load_images(tagFile, imgHeight, imgWidth):
  lbls = labels();

  all_images = []
  all_labels = []
  with open(tagFile) as f:
    tagSet = [x.strip() for x in f.readlines()]

  for tag in tagSet:
    lbl, imgTag = os.path.split(tag)
    iLbl        = iLabel(lbl, lbls)

    imgFile     = os.path.join("food_mnist", "images", lbl, imgTag+".jpg" )
    img         = transform_image(imgFile, imgHeight, imgWidth)

    all_images.append(img)
    all_labels.append(iLbl)

  return np.array(all_images), all_labels

"""##  load_data(width, height)

 **Returns:**

 It returns two tuples
1. x_train, x_test: uint8 array of RGB image data with shape (num_samples, width, height, 3) from the image_data_format backend setting o either channels_first or channels_last respectively.
2. y_train, y_test: uint8 array of category labels (integers in range 0-9) with shape (num_samples,).

**Example Usage**

      (x_train, y_train), (x_test, y_test) = food_mnist.load_data()
      labels_dict = food_mnist.labels()
"""

def load_data(imgWidth=224, imgHeight=224):

  (x_train, y_train) = load_images(os.path.join("food_mnist", "meta", "train.txt"), imgWidth, imgHeight)
  (x_test, y_test)   = load_images(os.path.join("food_mnist", "meta", "test.txt"), imgWidth, imgHeight)



  return (x_train, y_train), (x_test, y_test)

"""%%time
if __name__ == "__main__":
  (x_train, y_train), (x_test, y_test) = load_data();
"""
